from glob import glob
import json
from typing import Union

def _get_version_from_fp(fp: str) -> str:
    version = fp.rstrip('.sav')[fp.index('PHSaveMain')+len('PHSaveMain'):].lstrip('-')
    assert len(version) >= 2 and version.startswith('v'), \
        'Invalid version parsed: {!r}\n  filepath: {!r}'.format(version, fp)
    return version


def remap_all(saves_fp_glob_str: str, out_fp_format: str, _pretty: Union[int, bool] = False,
              get_version_from_fp = _get_version_from_fp):
    versions_mapped_successfully = []

    for fp in glob(saves_fp_glob_str):
        # infer version from filename
        version = get_version_from_fp(fp)
        # read properties lines from save file
        with open(fp, 'r') as f:
            contents = f.readlines()

        # remap contents
        # note: for now, saves are all in plaintext, so there is no decryption or decoding needed.
        mappings: dict[str,str] = remap_file(contents, version)
        if mappings is None:
            print('WARN: Failed mapping file {!r}.'.format(fp))
            continue

        # save intermediate mappings dict
        with open(out_fp_format.format(version=version), 'w') as f:
            json.dump(mappings, f,
                      indent=(_pretty if isinstance(_pretty, int) else (2 if bool(_pretty) else None)))

        versions_mapped_successfully.append(version)

    print('remap_all(...): mapped save versions: {!r}'.format(versions_mapped_successfully))


def remap_file(contents: list[str], version: str) -> dict[str,str]:
    '''remap properties and their values to the intermediate mapping'''
    mappings = dict()
    for line in contents:
        line = line.rstrip('\n')
        if len(line) == 0:
            continue
        parts = line.split('@')
        if(len(parts) != 3):
            print('ERROR: property line as it did not have 3 parts when splitting on \'@\', instead {}.'.format(len(parts)))
            print('  (property line: {!r})'.format(line))
            return None
        if(len(parts[0]) > 0):
            print('Unexpected string found before property name: {!r}'.format(parts[0]))
            print('  (property line: {!r})'.format(line))
        if(len(parts[1]) <= 0):
            print('ERROR: No property name found.')
            print('  (property line: {!r})'.format(line))
            return None
        if(len(parts[2]) <= 0):
            print('ERROR: No property value found for property {!r}'.format(parts[1]))
            print('  (property line: {!r})'.format(line))
            return None
        # note: for now, there is no difference found in supported versions,
        #  so a property's name equals its intermediate mapping. (No decryption or decoding needed)
        _, propname, propval = parts

        mappings[propname] = propval
    
    return mappings


savemap_fp_prefix = './saves_mapped/mapped-'
savemap_fp_default_suffix = '-default.json'
savemap_fp_relevant_suffix = '-relevant.json'

if __name__ == '__main__':

    ## 1. map saves into their intermediate properties, which have manually detailed info in json files

    # map default saves to their properties
    remap_all('./saves_default/PHSaveMain-*.sav', savemap_fp_prefix+'{version}'+savemap_fp_default_suffix, _pretty=True)
    # map relevant saves (containing all actually-used properties, afaik) to their properties
    remap_all('./saves_relevant/PHSaveMain-*.sav', savemap_fp_prefix+'{version}'+savemap_fp_relevant_suffix, _pretty=True)


    ## 2. move jsons into javascript files

    print('moving data into generated .js files')
    
    # move general properties info
    with open('../docs/js/props_info_generated.js', 'w') as jsf:
        # comment notifying people who open the file that it was generated (by this script)
        jsf.write('// generated by the mapping script\n')
        # insert the property info as a javascript object (json) const
        with open('./mapped_prop_info.json', 'r') as jsonf:
            jsf.write('const PROP_INFO = {};'.format(json.dumps(json.load(jsonf), indent=4)))

    # move general categories ordering info
    with open('../docs/js/props_categories_generated.js', 'w') as jsf:
        # comment notifying people who open the file that it was generated (by this script)
        jsf.write('// generated by the mapping script\n')
        # insert the categories info as a javascript object (json) const
        with open('./mapped_prop_categories.json', 'r') as jsonf:
            jsf.write('const CATEGORY_INFO = {};'.format(json.dumps(json.load(jsonf), indent=4)))

    # generate the default properties info
    with open('../docs/js/version_prop_defaults_generated.js', 'w') as jsf:
        # comment notifying people who open the file that it was generated (by this script)
        jsf.write('// generated by the mapping script\n')

        # collect/aggregate info from every version's mapped default save
        contents_defaults = {}
        for mapped_save_fp in glob(savemap_fp_prefix+'*'+savemap_fp_default_suffix):
            # obtain version from file name
            version = mapped_save_fp.replace('\\','/').removeprefix(savemap_fp_prefix).removesuffix(savemap_fp_default_suffix)
            assert len(version) > 0 and version[0] == 'v', f'unexpected version name {version!r}'
            # put that mapped default save file's info into the aggregating dict
            with open(mapped_save_fp, 'r') as jf:
                contents_defaults[version] = json.load(jf)
        jsf.write('const VERSION_DEFAULTS = {};'.format(json.dumps(contents_defaults, indent=4)))
    
    # generate the actually-used properties info; i.e., relevant properties.
    #   Because: the default does not necessarily contain all values (example: collected soul jar, unlocked level, etc.)
    #    and can also contain unused values (example: item id 199 doesn't exist)
    with open('../docs/js/version_prop_relevants_generated.js', 'w') as jsf:
        # comment notifying people who open the file that it was generated (by this script)
        jsf.write('// generated by the mapping script\n')

        # collect/aggregate info from every version's mapped all-relevant save
        contents_all = {}
        for mapped_save_fp in glob(savemap_fp_prefix+'*'+savemap_fp_relevant_suffix):
            # obtain version from file name
            version = mapped_save_fp.replace('\\','/').removeprefix(savemap_fp_prefix).removesuffix(savemap_fp_relevant_suffix)
            assert len(version) > 0 and version[0] == 'v', f'unexpected version name {version!r}'
            # put that mapped all-relevant save file's info into the aggregating dict
            with open(mapped_save_fp, 'r') as jf:
                contents_all[version] = json.load(jf)
        jsf.write('const VERSION_RELEVANTS = {};'.format(json.dumps(contents_all, indent=4)))


    ## 3. move the item and clothing names into javascript files

    with open('../docs/js/name_maps_generated.js', 'w') as jsf:
        # comment notifying people who open the file that it was generated (by this script)
        jsf.write('// generated by the mapping script\n')

        # items
        with open('./name_maps/item_name_map.json') as jsonf:
            jsf.write('const NAME_MAP_ITEMS = {};\n'.format(json.dumps(json.load(jsonf), indent=4)))
        # clothing
        with open('./name_maps/clothing_name_map.json') as jsonf:
            jsf.write('const NAME_MAP_CLOTHING = {};\n'.format(json.dumps(json.load(jsonf), indent=4)))

    print('all mapping and javascript generating done!')
